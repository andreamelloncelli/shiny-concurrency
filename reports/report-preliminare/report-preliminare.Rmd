---
title: "Report preliminare Progetto Shiny Concurrency"
author: "Andrea Melloncelli"
date: "6/12/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Infrastruttura

L'infrastruttura è composta da 4 macchine:

* 1 AWS server MySQL
* 1 AWS server con Shiny Server Pro
* 1 AWS server con RStudio che lancia le richeste simulate
* 1 virtual-machine locale che lancia le richieste simulate dal di fuori della rete AWS

Gli AWS server sono macchine con 2 core, 8 Gb di RAM, memoria di massa a disco magnetico. Tutte le macchine possono essere scelte piu' veloci con dischi a stato solido (più velocità in lettura e scrittura).

## L'applicazione Shiny (senza aggregazione)

L'applicazione è creata per mostrare la serie temporale dei dati della tabella `historydata` filtrata su un giorno (quello selezionato dall'utente) e su un `id_channel` di default:

```{r, eval=FALSE}
data_get <- function(tbl, from, to) {
	from <- as_datetime(from) %>% as_epoch
	to   <- as_datetime(to) %>% as_epoch
	tbl %>%
		filter( from < time, time < to,
						id_channel == 1 ) %>% 
		collect %>% 
		mutate( time = as_datetime(time) )
}
```

L'interfaccia è minimale: un menu per scegliere la data e un plot javascript. Nei test preliminari (questi) per evitare problemi di compatibilità il plot è sostituito con la conversione in JSON della serie temporale. Questa scelta in ragione del fatto che ritengo che buona parte della computazione lato server è la conversione e l'invio dei dati al client.

## Test

### Modalità di test

Il test si divide in 3 fasi:

1. registrazione della sessione: viene aperto un browser con l'applicazione, vengono registrate le interazioni con l'utente e le risposte del server fino alla chiusura del browser.

2. simulazione della sessione: vengono lanciate `n` simulazioni concorrenti della sessione registrata. Per ogni richiesta terminata ne viene aperta un'altra, con il fine di mantenere il carico del server a numero di utenti massimo. 

3. Generazione del report.

La fase di test (2.) è pensata per tenere il server con il numero massimo di sessioni attive per una certa durata (`duration`), la quale vuole essere superiore alla durata della sessione registrata. Per ottenere questo risultato al termine di ogni sessione ne viene lanciata un'altra identica.

### Primo test

Nel nostro caso la sessione dura circa 45 secondi. Ogni sessione viene ripetuta un numero di volte sufficente a tenere il server impegnato con le `n` connessioni per la `duration` stabilita (varia a seconda dei test).

La registrazione è cosi' composta:

1. caricamento della pagina. Da fine caricamento una pausa di 15 secondi per guardare il risultato.

2. primo click sul widget delle date.

3. secondo click su un'altra data (questo causa il lancio della query sul db e la visualizzazione dei risultati)

4. terzo clicx su un'altra data (stesso effetto di ricalcolo) (NB: senza pausa)

Riassumiamo. 4 tempi: il caricamento della pagina e tre di interazione con l'utente.

### Esempi dei file di registrazione

Prime righe di un file di registrazione:

```
# Target: http://ec2-52-201-221-45.compute-1.amazonaws.com:3838/shinyTest/
{"type":"REQ_HOME","created":"2017-12-05T16:49:38.822Z","method":"GET","url":"/","statusCode":200}
{"type":"REQ","created":"2017-12-05T16:49:39.588Z","method":"GET","url":"/_w_${WORKER}/shared/json2-min.js","statusCode":200}
{"type":"REQ","created":"2017-12-05T16:49:39.747Z","method":"GET","url":"/_w_${WORKER}/shared/jquery.min.js","statusCode":200}
{"type":"REQ","created":"2017-12-05T16:49:39.745Z","method":"GET","url":"/_w_${WORKER}/shared/shiny.css","statusCode":200}
{"type":"REQ","created":"2017-12-05T16:49:39.750Z","method":"GET","url":"/_w_${WORKER}/shared/shiny.min.js","statusCode":200}
[...]
```

File risultato di un playback (`profile_0_0.txt`):

```
1	2017-12-05T23:29:44.972Z	478	REQ_HOME	0
2	2017-12-05T23:29:45.318Z	345	REQ	0
3	2017-12-05T23:29:46.149Z	831	REQ	0
4	2017-12-05T23:29:46.500Z	351	REQ	0
5	2017-12-05T23:29:47.161Z	661	REQ	0
6	2017-12-05T23:29:47.645Z	484	REQ	0
7	2017-12-05T23:29:48.322Z	677	REQ	0
8	2017-12-05T23:29:49.101Z	779	REQ	0
9	2017-12-05T23:29:49.443Z	341	REQ	0
10	2017-12-05T23:29:49.932Z	488	REQ	0
11	2017-12-05T23:29:50.279Z	347	REQ	0
12	2017-12-05T23:29:50.917Z	638	REQ	0
13	2017-12-05T23:29:51.407Z	490	REQ	0
14	2017-12-05T23:29:51.773Z	366	REQ	0
15	2017-12-05T23:29:52.106Z	333	REQ_TOK	0
16	2017-12-05T23:29:52.454Z	348	REQ	0
17	2017-12-05T23:29:52.790Z	336	REQ_SINF	0
18	2017-12-05T23:29:53.148Z	358	WS_OPEN	0
19	2017-12-05T23:29:53.149Z	1	WS_RECV	0
20	2017-12-05T23:29:53.309Z	1	WS_SEND	158
21	2017-12-05T23:29:53.320Z	0	WS_SEND	1
22	2017-12-05T23:29:53.601Z	281	WS_RECV	0
23	2017-12-05T23:29:53.602Z	1	WS_RECV_INIT	0
24	2017-12-05T23:29:53.918Z	316	WS_RECV	0
25	2017-12-05T23:30:12.793Z	1	WS_SEND	18856
26	2017-12-05T23:30:13.134Z	341	WS_RECV	0
27	2017-12-05T23:30:16.649Z	0	WS_SEND	3513
28	2017-12-05T23:30:16.955Z	305	WS_RECV	0
29	2017-12-05T23:30:31.290Z	1	WS_CLOSE	14321
# Success
# Job finished in 46797ms
```

### Reports

Ad ogni file di report viene dato un nome invormativo. Esempio

`report_output_10_mysql_001usr_4thr_100-090-40_2min_net`

le parti degne di nota sono:

`report_output_<id>_mysql_<number-concurrent-users>usr_4thr_100-090-40_<duration>min_<test-machine>`

1. id: è un semplice id numerico unico del test
2. number-concurrent-users: numero di utenti concorrenti richiesti
3. duration: vedi sopra
4. test-machine: è la macchina di test. Due possibilità `net` il server AWS oppure `vb` la mia virtualbox-machine (su rete 4G)

## Risultati preliminari

### Importanza della banda

Ho allegato sia i test fatti in rete locale che quelli da rete 4G, perche' ritengo che in questo test la rete sia un collo di bottiglia non indifferente. Si pensi che in un test da 6 minuti con 200 utenti concorrenti sono stati scambiati circa 600 Mb in modo tuttaltro che uniforme (molto impulsivo). Penso che questo sia determinato dal fatto che al caricamento della pagina la simulazione scarichi tutte le librerie Javascript, e le 200 richieste iniziali partono quasi contemporaneamente.

### Test da macchina remota Virtualbox

Il [test 52](./report_output_52_mysql_001usr_4thr_100-090-40_2min_vb.html) rappresenta l'utilizzo reale di prova in fase di sviluppo: 1 solo utente e i tempi di latenza reali perchè la macchina è remota.

Il [test 54](./report_output_54_mysql_200usr_4thr_100-090-40_6min_vb.html) è quello che potrebbe essere considerato più completo: 200 utenti e tempi di latenza realistici. Invece sembra fortemente influenzato dalla banda: Utilizzando 2 connessioni diverse(testato senza la creazione di un report) i risultati dei test cambiano sensibilmente. Questo non può essere dovuto quindi ad altro.

### Test da macchina locale in rete AWS

Il [test 10](./report_output_10_mysql_001usr_4thr_100-090-40_2min_net.html) invece è quello che si ottiene con un solo utente in rete locale AWS (molto veloce ~ 100 Mb/s e a bassa latena). I tempi si abbassano molto: sembra che i tempi siano dovuti quasi interamente alla latenza di rete. A riprova di questo si puo' dire che durante i test la macchina non arriva al 100% dell'utilizzo delle cpu.

Il [test 11](./report_output_11_mysql_200usr_4thr_100-090-40_2min_net.html) è infine il test con la concorrenza voluta, ma con una bassissima latenza di rete.

### Altre verifiche fatte

L'applicazione scrive un file di log, che differenzia la fase di inizializzazione dalla fase di query (click dell'utente). Durante i test è stato verificato che questi log venissero scritti e si è anche evidenziata la differenza tra la fase di inizializzazione della pagina e quella di semplice lancio della query. Durante l'inizializzazione infatti viene lanciata sia l'inizializzazione che la query, in fase di click solo la query.



